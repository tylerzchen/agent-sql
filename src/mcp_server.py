import os
import logging
import json
from mcp.server.fastmcp import FastMCP
from dotenv import load_dotenv

from prompt import create_system_prompt
from sql_agent import SQLAgent
from rds_client import RDSClient

load_dotenv()

CLUSTER_ARN = os.getenv("AURORA_CLUSTER_ARN")
SECRET_ARN = os.getenv("AURORA_SECRET_ARN")
DB_NAME = os.getenv("DATABASE_NAME")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

mcp = FastMCP("sql-agent")
sql_agent = SQLAgent()

connection_success, connection_error = None, None
try:
    rds_client = RDSClient(cluster_arn=CLUSTER_ARN, secret_arn=SECRET_ARN, db_name=DB_NAME)
    connection_success, connection_error = rds_client.test_connection()
    if not connection_success:
        logger.error(f"Failed to connect to RDS: {connection_error}")
    else:
        logger.info("Connection to RDS successful")
except Exception as error:
    connection_success = False
    connection_error = f"Failed to connect to RDS: {str(error)}"
    logger.error(f"Failed to connect to RDS: {connection_error}")

@mcp.prompt("Generate SQL Query")
async def generate_sql_query(user_query: str) -> str:
    """Convert a natural language query into a valid SQL query to be executed on the database.

    This prompt is used to help Claude generate SQL queries baesd on the user's query and
    the database schema. Use this when you need to convert a natural language query into SQL.

    Args:
        user_query: the natural language query about the database (e.g., "Show me all tickets that are overdue and still unresolved")
    """
    return create_system_prompt(user_query=user_query)

@mcp.tool()
async def query_sql_agent(user_query: str) -> str:
    """Convert a natural language query into a valid SQL query to be executed on the database.

    This tool is used to convert a natural language query related to the following
    database tables -- tickets, ticket categories, ticket priorities, ticket statuses, 
    messages, message types -- into a secure and validated PostgreSQL SELECT query,
    then execute the query on the database and return the results.

    IMPORTANT:
    First call generate_sql_query to get the system prompt, then use that prompt to 
    generate the SQL query, then call the execute_sql_query tool to execute the query
    on the database and return the results.
    
    Args:
        user_query: the natural language query about the database (e.g., "Show me all tickets that are overdue and still unresolved")
    """
    if not connection_success:
        logger.error(f"Database connection not available: {connection_error}")
        return json.dumps({
            "success": False,
            "error": f"Database service unavailable: {connection_error}",
            "user_query": user_query,
            "retry_advice": "The database service is currently unavailable. Please try again later.",
            "error_type": "connection_error"
        }, indent=2)
    
    try:
        system_prompt = create_system_prompt(user_query=user_query)
        return json.dumps({
            "success": True,
            "message": "Please use the following prompt to generate SQL, then call execute_sql_query with the result:",
            "system_prompt": system_prompt,
            "next_step": "Call execute_sql_query with the generated SQL",
            "user_query": user_query,
            "instructions": [
                "1. Use the system_prompt above to generate valid SQL",
                "2. Extract the SQL from the <sql_statement> tags",
                "3. Call execute_sql_query with the generated SQL and user_query"
            ]
        }, indent=2)
    except Exception as error:
        logger.error(f"Unknown error: {str(error)}")
        return json.dumps({
            "success": False,
            "error": str(error),
            "user_query": user_query,
            "generated_sql": None
        }, indent=2)

@mcp.tool()
async def execute_sql_query(sql_query: str, user_query: str = "") -> str:
    """Execute a SQL query on the database and return the results.

    This tool is used to execute pre-generated SQL queries on the database.
    The SQL query should be generated by Claude using the generate_sql_query prompt,
    based on the database schema and the user's query.

    Args:
        sql_query: the SQL query to execute on the database
        user_query: the original natural language query that generated the SQL query for context (optional)
    """
    if not connection_success:
        logger.error(f"Database connection not available: {connection_error}")
        return json.dumps({
            "success": False,
            "error": f"Database service unavailable: {connection_error}",
            "sql_query": sql_query,
            "user_query": user_query,
            "retry_advice": "The database service is currently unavailable. Please try again later.",
            "error_type": "connection_error"
        }, indent=2)

    try:
        is_valid, error = sql_agent.validate_sql(sql_query)
        if not is_valid:
            logger.error(f"Invalid SQL query: {error}")
            return json.dumps({
                "success": False,
                "error": f"Invalid SQL query: {error}",
                "user_query": user_query,
                "generated_sql": sql_query,
                "error_type": "security_error"
            }, indent=2)
        
        result = rds_client.execute_query(sql_query)
        if not result['success']:
            logger.error(f"Database query failed: {result['error']}")
            return json.dumps({
                "success": False,
                "error": f"Database query failed: {result['error']}",
                "user_query": user_query,
                "generated_sql": sql_query,
                "data": None,
                "row_count": 0,
                "columns": [],
                "error_type": "database_error"
            }, indent=2)
        
        return json.dumps({
            "success": True,
            "user_query": user_query,
            "generated_sql": sql_query,
            "validation_passed": True,
            "data": result['data'],
            "row_count": result['row_count'],
            "columns": result['columns'],
        }, indent=2, default=str)
    except Exception as error:
        logger.error(f"Unexpected error in execute_sql_query: {str(error)}")
        return json.dumps({
            "success": False,
            "error": f"Unexpected error: {str(error)}",
            "user_query": user_query,
            "generated_sql": sql_query,
            "retry_advice": "Please try again later.",
            "error_type": "unexpected_error"
        }, indent=2)

if __name__ == "__main__":
    logger.info("Starting MCP server...")
    mcp.run(transport="stdio")